package fr.xebia.image.core

import fr.xebia.image.ImageBuilder
import fr.xebia.image.TestFactory.ImagingTools._
import fr.xebia.image.TestFactory._
import fr.xebia.image.export.{CharValueGradientOnHeight, GrayGradientOnHeight, ImageWriter, Rainbow}
import org.scalatest.concurrent.{PatienceConfiguration, ScalaFutures}
import org.scalatest.time.{Seconds, Span}
import org.scalatest.{Matchers, WordSpec}

import scala.util.Success

class ImageFunctorSpec extends WordSpec with Matchers with ScalaFutures {

  "A segmentation functor" which {

    "handles hardcoded images" must {

      "replace '#' by '@'" in {
        // given an image
        val functor = anImageFunctorFrom("""
            |......###........
            |...###...##......
            |..##.......##....
            |..#..........#...
            |..#..........#...
            |..#.........##...
            |..###......###...
            |...###...###.....
            |.....####........
            |.................
          """.stripMargin)
        // when
        val segmentedImg = functor.threshold(
          cell => cell == "#",
          replaceBy = "@"
        )

        // then
        segmentedImg shouldBe anImageFunctorFrom(
          """
            |......@@@........
            |...@@@...@@......
            |..@@.......@@....
            |..@..........@...
            |..@..........@...
            |..@.........@@...
            |..@@@......@@@...
            |...@@@...@@@.....
            |.....@@@@........
            |.................
          """.stripMargin
        )
      }

      "detect a missing first match in the image" in {
        val aFunctor = anImageFunctorFrom("""|......###........
            |...###...##......
            |..##.......##....
            |..############...
            |.................
            |.................
            |..############...
            |...#########.....
            |.....####........
            |.................
          """.stripMargin)
        aFunctor.firstThatMatches("&") shouldNot be(defined)
      }

      "apply threshold on a matching predicate" in {
        val anImageFunctor = anImageFunctorFrom("""
            |-#--#----
            |-#--#--#-
            |-#--#--#-
            |-#--#----
          """.stripMargin)
        val expectedContent = anImageFunctorFrom(
          """
            |---------
            |---------
            |---------
            |---------
          """.stripMargin
        )
        anImageFunctor.threshold(predicate = (p) => p == "#", replaceBy = "-") shouldBe expectedContent
      }

      "not apply threshold if none match the predicate" in {
        val anImageFunctor = anImageFunctorFrom("-#--#----")
        val expectedContent = anImageFunctorFrom("-#--#----")
        anImageFunctor.threshold(predicate = (p) => p == "@", replaceBy = "-") shouldBe expectedContent
      }

      "propagate a front from a simple image" in {
        val aContent =
          """
            |-#--#----
            |-#--#--#-
            |-#--#--#-
            |-#--#----
          """.stripMargin
        val anImageFunctor = anImageFunctorFrom(aContent)
        anImageFunctor.countConnectedElements("#", "-") shouldBe 3
      }

    }

    "reads files" must {

      "detect unconnected elements in an image from disk" in {
        val aFunctor = ImageBuilder.StringImageFromFile("/google.txt")
        aFunctor.countConnectedElements(
          contentValue = "#",
          emptyValue = "."
        ) shouldBe 6
      }

      "detect the right amt of characters from a file containing 'xebia' " in {
        val aFunctor = ImageBuilder.StringImageFromFile("/xebia.txt")
        aFunctor.countConnectedElements(
          contentValue = "#",
          emptyValue = "."
        ) shouldBe 5
      }

    }

    "executes front propagation" must {

      val anImageFunctor = anImageFunctorFrom("""
          |......###........
          |...###...##......
          |..##.......##....
          |..############...
          |.................
          |.................
          |..############...
          |...#########.....
          |.....####........
          |.................
        """.stripMargin)

      "propagate a front from a specified seed" in {
        // given
        val specialChar = "@"
        val seed = Position(7, 0)

        // when
        val anImageFunctor = anImageFunctorFrom("""
            |......###........
            |...###...##......
            |..##.......##....
            |..############...
            |..#..........#...
            |..#.........##...
            |..############...
            |...###...###.....
            |.....####........
            |.................
          """.stripMargin)

        val segmentedPositions = anImageFunctor.propagateFront(
          seed = seed,
          searchedValue = "#",
          markWith = specialChar
        )
        val segmentedImage = anImageFunctor.replace(segmentedPositions, specialChar)

        // then
        segmentedImage.image.content shouldBe anImageFunctorFrom(
          """
            |......@@@........
            |...@@@...@@......
            |..@@.......@@....
            |..@@@@@@@@@@@@...
            |..@..........@...
            |..@.........@@...
            |..@@@@@@@@@@@@...
            |...@@@...@@@.....
            |.....@@@@........
            |.................
          """.stripMargin
        ).image.content
      }

      "propagate a front from the first value that matches" in {
        // given
        val firstFrontFunctor = anImageFunctor
        val firstSeed = aSeedThatMatches(firstFrontFunctor, Position(6, 0), "#")

        // when the first functor is called
        val firstFront: List[Position] = firstFrontFunctor.propagateFront(
          seeds = List(firstSeed),
          searchedValue = "#",
          markWith = "@"
        )
        firstFront shouldNot be(empty)

        // when the second functor
        val secondFrontFunctor = firstFrontFunctor.replace(firstFront, "@")
        val secondSeed = aSeedThatMatches(secondFrontFunctor, Position(2, 6), "#")

        val secondFront: List[Position] = secondFrontFunctor.propagateFront(
          seeds = List(secondSeed),
          searchedValue = "#",
          markWith = "&"
        )
        secondFrontFunctor.replace(secondFront, "&") shouldBe anImageFunctorFrom(
          """
            |......@@@........
            |...@@@...@@......
            |..@@.......@@....
            |..@@@@@@@@@@@@...
            |.................
            |.................
            |..&&&&&&&&&&&&...
            |...&&&&&&&&&.....
            |.....&&&&........
            |.................
          """.stripMargin
        )
      }

      "detect unconnected elements in an image" in {
        val anImageFunctor = anImageFunctorFrom("""
            |.................
            |...##......##....
            |...##......##....
            |...##......##....
            |.................
            |.................
            |..##........##...
            |...##......##....
            |.....######......
            |.................
          """.stripMargin)
        anImageFunctor.countConnectedElements(
          contentValue = "#",
          emptyValue = "."
        ) shouldBe 3
      }

    }

  }

  "An exporter mechanism" must {
    import scala.concurrent.ExecutionContext.Implicits.global
    val timeout = PatienceConfiguration.Timeout(Span(2, Seconds))

    "read and write a String image" in {
      import java.nio.file.{Files, Paths}
      val aFileName: String = "output.png"
      val anImageFunctor = anImageFunctorFrom("""
          |.................
          |...##......##....
          |...##......##....
          |...##......##....
          |.................
          |.................
          |..##........##...
          |...##......##....
          |.....######......
          |.................
        """.stripMargin)

      val eventualResponse =
        ImageWriter.writeToImage(aFileName, anImageFunctor.image, (pixel: String) => pixel == "#", GrayGradientOnHeight)
      whenReady(eventualResponse, timeout) { response =>
        Files.exists(Paths.get(aFileName))
      }
    }

    "read and write a String image using searched char as color value" in {
      import java.nio.file.{Files, Paths}
      val aFileName: String = "outputValue.png"
      val anImageFunctor = anImageFunctorFrom("""
          |.................
          |...¨¨......¨¨....
          |...¨¨......¨¨....
          |...¨¨......¨¨....
          |.................
          |.................
          |..÷÷........÷÷...
          |...÷÷......÷÷....
          |.....÷÷÷÷÷÷......
          |.................
        """.stripMargin)

      val eventualResponse = ImageWriter.writeToImage(aFileName,
                                                      anImageFunctor.image,
                                                      (pixel: String) => pixel != ".",
                                                      CharValueGradientOnHeight)
      whenReady(eventualResponse, timeout) { response =>
        Files.exists(Paths.get(aFileName))
      }
    }

    "read and write an Int image" in {
      import java.nio.file.{Files, Paths}
      val aFileName = "outputColor.png"
      val aNumericImageFunctor = ImageBuilder.IntImageFromFile("/input.txt")
      aNumericImageFunctor match {
        case Success(func) =>
          val eventualResponse =
            ImageWriter.writeToImage(aFileName, func.image, (pixel: Int) => pixel == 255, Rainbow)
          whenReady(eventualResponse, timeout) { response =>
            Files.exists(Paths.get(aFileName))
          }
        case _ =>
          fail("Error parsing int image")
      }

    }

  }

}
