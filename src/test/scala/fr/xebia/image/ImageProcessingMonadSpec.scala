package fr.xebia.image

import fr.xebia.image.ImagingTools._
import org.scalatest.concurrent.Futures
import org.scalatest.{FunSpec, Matchers}

import scala.concurrent.Await

class ScalaTestExampleSpec extends FunSpec with Matchers with Futures {

  describe("a segmentation monad") {

    it("should replace '#' by '@'") {
      // given an image
      val monad = TestImageBuilder.fromString(
        """
          |......###........
          |...###...##......
          |..##.......##....
          |..#..........#...
          |..#..........#...
          |..#.........##...
          |..###......###...
          |...###...###.....
          |.....####........
          |.................
        """.stripMargin)

      // when
      val segmentedImg = monad.threshold(
        cell => cell == "#",
        replaceBy = "@"
      )

      // then
      segmentedImg shouldBe TestImageBuilder.fromString(
        """
          |......@@@........
          |...@@@...@@......
          |..@@.......@@....
          |..@..........@...
          |..@..........@...
          |..@.........@@...
          |..@@@......@@@...
          |...@@@...@@@.....
          |.....@@@@........
          |.................
        """.stripMargin
      )
    }

    it("should propagate a front from a specified seed") {
      // given
      val specialChar = "@"
      val seed = Position(0, 7)

      // when
      val monad = TestImageBuilder.fromString(
        """
          |......###........
          |...###...##......
          |..##.......##....
          |..############...
          |..#..........#...
          |..#.........##...
          |..############...
          |...###...###.....
          |.....####........
          |.................
        """.stripMargin)

      val segmentedPositions = monad.propagateFront(
        seeds = monad.neighborsAndSelf(seed),
        searchedValue = "#",
        markWith = specialChar
      )
      val segmentedImage = monad.replace(segmentedPositions, specialChar)

      // then
      segmentedImage shouldBe TestImageBuilder.fromString(
        """
          |......@@@........
          |...@@@...@@......
          |..@@.......@@....
          |..@@@@@@@@@@@@...
          |..@..........@...
          |..@.........@@...
          |..@@@@@@@@@@@@...
          |...@@@...@@@.....
          |.....@@@@........
          |.................
        """.stripMargin
      )
    }

  }

  describe("a segmentation monad executing front propagation") {

    val monad = TestImageBuilder.fromString(
      """|......###........
        |...###...##......
        |..##.......##....
        |..############...
        |.................
        |.................
        |..############...
        |...#########.....
        |.....####........
        |.................
      """.stripMargin)

    it("should detect a missing first match in the image") {
      monad.getFirstThatMatches("&") shouldNot be(defined)
    }

    it("should propagate a front from the first value that matches") {
      // given
      val firstFrontMonad = monad
      val firstSeed = aSeedThatMatches(firstFrontMonad,  Position(0, 6), "#")

      // when the first monad is called
      val firstFront: List[Position] = firstFrontMonad.propagateFront(
        seeds = List(firstSeed),
        searchedValue = "#",
        markWith = "@"
      )
      firstFront shouldNot be(empty)

      // when the second monad
      val secondFrontMonad = firstFrontMonad.replace(firstFront, "@")
      val secondSeed = aSeedThatMatches(secondFrontMonad, Position(6, 2), "#")

      val secondFront: List[Position] = secondFrontMonad.propagateFront(
        seeds = List(secondSeed),
        searchedValue = "#",
        markWith = "&"
      )
      secondFrontMonad.replace(secondFront, "&") shouldBe TestImageBuilder.fromString(
        """
          |......@@@........
          |...@@@...@@......
          |..@@.......@@....
          |..@@@@@@@@@@@@...
          |.................
          |.................
          |..&&&&&&&&&&&&...
          |...&&&&&&&&&.....
          |.....&&&&........
          |.................
        """.stripMargin
      )
    }

    it("should detect several different elements in the image") {
      val monad = TestImageBuilder.fromString(
        """
          |.................
          |...##......##....
          |...##......##....
          |...##......##....
          |.................
          |.................
          |..###......###...
          |...##.....##.....
          |.....#####.......
          |.................
        """.stripMargin)
      monad.countConnectedElements(
        contentValue = "#",
        emptyValue = "."
      ) shouldBe 3
    }

  }

  describe("a segmentation monad") {
    import scala.concurrent.ExecutionContext.Implicits.global

    val monad = TestImageBuilder.fromString(
      """
        |.................
        |...##......##....
        |...##......##....
        |...##......##....
        |.................
        |.................
        |..##........##...
        |...##......##....
        |.....######......
        |.................
      """.stripMargin)

    it("should write a file from the matrix") {
      import scala.concurrent.duration._
      Await.ready(monad.writeToImage("#", "output.png"), 2.seconds)
    }

  }

}

object ImagingTools {

  def aSeedThatMatches(processingMonad: ImageProcessingMonad[String], position: Position, expectedValue: String): Position = {
    val firstSeed = processingMonad
      .getFirstThatMatches("#")
      .getOrElse(throw new IllegalStateException("# not found"))
    assert(firstSeed == position)
    assert(processingMonad.at(firstSeed) == "#")
    firstSeed
  }

  def writeToFile(processingMonad: ImageProcessingMonad[String], front: List[Position], fileName: String, newContent: String = "@"): Unit =
    processingMonad.replace(front, newContent).writeToFile(fileName)

  object TestImageBuilder {

    def fromString(rawContent: String): ImageProcessingMonad[String] = {
      val contents: List[List[String]] = rawContent
        .split("\n")
        .map(_.toCharArray.toList.map(_.toString))
        .toList
        .filter(_.map(_.trim).mkString.nonEmpty)
      ImageProcessingMonad(RawImage(contents))
    }

  }

}
