package fr.xebia.image.core

import fr.xebia.image.ImageBuilder
import fr.xebia.image.TestFactory.ImagingTools._
import fr.xebia.image.TestFactory._
import fr.xebia.image.export.{GrayGradientOnHeight, ImageWriter, Rainbow}
import org.scalatest.concurrent.{PatienceConfiguration, ScalaFutures}
import org.scalatest.time.{Seconds, Span}
import org.scalatest.{FunSpec, Matchers}

class ImageProcessingFunctorSpec extends FunSpec with Matchers with ScalaFutures {

  describe("a segmentation functor") {

    it("should replace '#' by '@'") {
      // given an image
      val functor = anImageWrapperFrom(
        """
          |......###........
          |...###...##......
          |..##.......##....
          |..#..........#...
          |..#..........#...
          |..#.........##...
          |..###......###...
          |...###...###.....
          |.....####........
          |.................
        """.stripMargin)
      // when
      val segmentedImg = functor.threshold(
        cell => cell == "#",
        replaceBy = "@"
      )

      // then
      segmentedImg shouldBe anImageWrapperFrom(
        """
          |......@@@........
          |...@@@...@@......
          |..@@.......@@....
          |..@..........@...
          |..@..........@...
          |..@.........@@...
          |..@@@......@@@...
          |...@@@...@@@.....
          |.....@@@@........
          |.................
        """.stripMargin
      )
    }

    it("should detect a missing first match in the image") {
      val aFunctor = anImageWrapperFrom(
        """|......###........
          |...###...##......
          |..##.......##....
          |..############...
          |.................
          |.................
          |..############...
          |...#########.....
          |.....####........
          |.................
        """.stripMargin)
      aFunctor.getFirstThatMatches("&") shouldNot be(defined)
    }

    it("should propagate front from a simple image") {
      val aContent =
        """
          |-#--#----
          |-#--#--#-
          |-#--#--#-
          |-#--#----
        """.stripMargin
      val anImageWrapper = anImageWrapperFrom(aContent)
      anImageWrapper.countConnectedElements("#", "-") shouldBe 3
    }


    it("should detect unconnected elements in an image from disk") {
      val aFunctor = ImageBuilder.StringImagefromFile("/google.txt").get
      aFunctor.countConnectedElements(
        contentValue = "#",
        emptyValue = "."
      ) shouldBe 6
    }

    it("should detect the right amt of characters from a file containing 'xebia' ") {
      val aFunctor = ImageBuilder.StringImagefromFile("/xebia.txt").get
      aFunctor.countConnectedElements(
        contentValue = "#",
        emptyValue = "."
      ) shouldBe 5
    }

  }

  describe("a segmentation functor executing front propagation") {
pending
    val anImageWrapper = anImageWrapperFrom(
      """|......###........
        |...###...##......
        |..##.......##....
        |..############...
        |.................
        |.................
        |..############...
        |...#########.....
        |.....####........
        |.................
      """.stripMargin)

    it("should propagate a front from a specified seed") {
      // given
      val specialChar = "@"
      val seed = Position(0, 7)

      // when
      val anImageFunctor = anImageWrapperFrom(
        """
          |......###........
          |...###...##......
          |..##.......##....
          |..############...
          |..#..........#...
          |..#.........##...
          |..############...
          |...###...###.....
          |.....####........
          |.................
        """.stripMargin)

      val segmentedPositions = anImageFunctor.propagateFront(
        seeds = anImageFunctor.neighborsAndSelf(seed),
        searchedValue = "#",
        markWith = specialChar
      )
      val segmentedImage = anImageFunctor.replace(segmentedPositions, specialChar)

      // then
      segmentedImage shouldBe anImageWrapperFrom(
        """
          |......@@@........
          |...@@@...@@......
          |..@@.......@@....
          |..@@@@@@@@@@@@...
          |..@..........@...
          |..@.........@@...
          |..@@@@@@@@@@@@...
          |...@@@...@@@.....
          |.....@@@@........
          |.................
        """.stripMargin
      )
    }

    it("should propagate a front from the first value that matches") {
      // given
      val firstFrontFunctor = anImageWrapper
      val firstSeed = aSeedThatMatches(firstFrontFunctor, Position(0, 6), "#")

      // when the first functor is called
      val firstFront: List[Position] = firstFrontFunctor.propagateFront(
        seeds = List(firstSeed),
        searchedValue = "#",
        markWith = "@"
      )
      firstFront shouldNot be(empty)

      // when the second functor
      val secondFrontFunctor = firstFrontFunctor.replace(firstFront, "@")
      val secondSeed = aSeedThatMatches(secondFrontFunctor, Position(6, 2), "#")

      val secondFront: List[Position] = secondFrontFunctor.propagateFront(
        seeds = List(secondSeed),
        searchedValue = "#",
        markWith = "&"
      )
      secondFrontFunctor.replace(secondFront, "&") shouldBe anImageWrapperFrom(
        """
          |......@@@........
          |...@@@...@@......
          |..@@.......@@....
          |..@@@@@@@@@@@@...
          |.................
          |.................
          |..&&&&&&&&&&&&...
          |...&&&&&&&&&.....
          |.....&&&&........
          |.................
        """.stripMargin
      )
    }

    it("should detect unconnected elements in an image") {
      val anImageFunctor = anImageWrapperFrom(
        """
          |.................
          |...##......##....
          |...##......##....
          |...##......##....
          |.................
          |.................
          |..##........##...
          |...##......##....
          |.....######......
          |.................
        """.stripMargin)
      anImageFunctor.countConnectedElements(
        contentValue = "#",
        emptyValue = "."
      ) shouldBe 3
    }

  }

  describe("a exporter mechanism") {
    import scala.concurrent.ExecutionContext.Implicits.global
    val timeout = PatienceConfiguration.Timeout(Span(2, Seconds))

    it("should read and write a String image") {
      import java.nio.file.{Files, Paths}
      val aFileName: String = "output.png"
      val anImageFunctor = anImageWrapperFrom(
        """
          |.................
          |...##......##....
          |...##......##....
          |...##......##....
          |.................
          |.................
          |..##........##...
          |...##......##....
          |.....######......
          |.................
        """.stripMargin)

      val eventualResponse = ImageWriter.writeToImage(
        aFileName,
        anImageFunctor.rawImage,
        (pixel: String) => pixel == "#",
        GrayGradientOnHeight)
      whenReady(eventualResponse, timeout) { response =>
        Files.exists(Paths.get(aFileName))
      }
    }

    it("should read and write an Int image") {
      import java.nio.file.{Files, Paths}
      val aFileName = "outputColor.png"
      val aNumericImageFunctor = ImageBuilder.IntImagefromFile("/input.txt").get
      val eventualResponse = ImageWriter.writeToImage(
        aFileName,
        aNumericImageFunctor.rawImage,
        (pixel: Int) => pixel == 255,
        Rainbow)
      whenReady(eventualResponse, timeout) { response =>
        Files.exists(Paths.get(aFileName))
      }
    }

  }

}
