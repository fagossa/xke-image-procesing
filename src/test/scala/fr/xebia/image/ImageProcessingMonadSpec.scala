package fr.xebia.image

import fr.xebia.image.ImagingTools._
import org.scalatest.concurrent.{PatienceConfiguration, ScalaFutures}
import org.scalatest.time.{Seconds, Span}
import org.scalatest.{OptionValues, FunSpec, Matchers}

class ScalaTestExampleSpec extends FunSpec with Matchers with ScalaFutures {

  describe("a segmentation monad") {

    it("should replace '#' by '@'") {
      // given an image
      val monad = TestImageBuilder.fromString(
        """
          |......###........
          |...###...##......
          |..##.......##....
          |..#..........#...
          |..#..........#...
          |..#.........##...
          |..###......###...
          |...###...###.....
          |.....####........
          |.................
        """.stripMargin)

      // when
      val segmentedImg = monad.threshold(
        cell => cell == "#",
        replaceBy = "@"
      )

      // then
      segmentedImg shouldBe TestImageBuilder.fromString(
        """
          |......@@@........
          |...@@@...@@......
          |..@@.......@@....
          |..@..........@...
          |..@..........@...
          |..@.........@@...
          |..@@@......@@@...
          |...@@@...@@@.....
          |.....@@@@........
          |.................
        """.stripMargin
      )
    }

    it("should detect a missing first match in the image") {
      val monad = TestImageBuilder.fromString(
        """|......###........
          |...###...##......
          |..##.......##....
          |..############...
          |.................
          |.................
          |..############...
          |...#########.....
          |.....####........
          |.................
        """.stripMargin)
      monad.getFirstThatMatches("&") shouldNot be(defined)
    }

    it("should detect unconnected elements in an image from disk") {
      val monad = ImageBuilder.fromFile("/google.txt").get
      monad.countConnectedElements(
        contentValue = "#",
        emptyValue = "."
      ) shouldBe 6
    }

  }

  describe("a segmentation monad executing front propagation") {

    val monad = TestImageBuilder.fromString(
      """|......###........
        |...###...##......
        |..##.......##....
        |..############...
        |.................
        |.................
        |..############...
        |...#########.....
        |.....####........
        |.................
      """.stripMargin)

    it("should propagate a front from a specified seed") {
      // given
      val specialChar = "@"
      val seed = Position(0, 7)

      // when
      val monad = TestImageBuilder.fromString(
        """
          |......###........
          |...###...##......
          |..##.......##....
          |..############...
          |..#..........#...
          |..#.........##...
          |..############...
          |...###...###.....
          |.....####........
          |.................
        """.stripMargin)

      val segmentedPositions = monad.propagateFront(
        seeds = monad.neighborsAndSelf(seed),
        searchedValue = "#",
        markWith = specialChar
      )
      val segmentedImage = monad.replace(segmentedPositions, specialChar)

      // then
      segmentedImage shouldBe TestImageBuilder.fromString(
        """
          |......@@@........
          |...@@@...@@......
          |..@@.......@@....
          |..@@@@@@@@@@@@...
          |..@..........@...
          |..@.........@@...
          |..@@@@@@@@@@@@...
          |...@@@...@@@.....
          |.....@@@@........
          |.................
        """.stripMargin
      )
    }

    it("should propagate a front from the first value that matches") {
      // given
      val firstFrontMonad = monad
      val firstSeed = aSeedThatMatches(firstFrontMonad, Position(0, 6), "#")

      // when the first monad is called
      val firstFront: List[Position] = firstFrontMonad.propagateFront(
        seeds = List(firstSeed),
        searchedValue = "#",
        markWith = "@"
      )
      firstFront shouldNot be(empty)

      // when the second monad
      val secondFrontMonad = firstFrontMonad.replace(firstFront, "@")
      val secondSeed = aSeedThatMatches(secondFrontMonad, Position(6, 2), "#")

      val secondFront: List[Position] = secondFrontMonad.propagateFront(
        seeds = List(secondSeed),
        searchedValue = "#",
        markWith = "&"
      )
      secondFrontMonad.replace(secondFront, "&") shouldBe TestImageBuilder.fromString(
        """
          |......@@@........
          |...@@@...@@......
          |..@@.......@@....
          |..@@@@@@@@@@@@...
          |.................
          |.................
          |..&&&&&&&&&&&&...
          |...&&&&&&&&&.....
          |.....&&&&........
          |.................
        """.stripMargin
      )
    }

    it("should detect unconnected elements in an image") {
      val monad = TestImageBuilder.fromString(
        """
          |.................
          |...##......##....
          |...##......##....
          |...##......##....
          |.................
          |.................
          |..##........##...
          |...##......##....
          |.....######......
          |.................
        """.stripMargin)
      monad.countConnectedElements(
        contentValue = "#",
        emptyValue = "."
      ) shouldBe 3
    }

  }

  describe("a exporter mechanism") {
    import scala.concurrent.ExecutionContext.Implicits.global
    val timeout = PatienceConfiguration.Timeout(Span(2, Seconds))

    val monad = TestImageBuilder.fromString(
      """
        |.................
        |...##......##....
        |...##......##....
        |...##......##....
        |.................
        |.................
        |..##........##...
        |...##......##....
        |.....######......
        |.................
      """.stripMargin)

    it("should write a file from the matrix") {
      import java.nio.file.{Files, Paths}
      val fileName: String = "output.png"
      val eventualUnit = ImageWriter.writeToImage((pixel: String) => pixel == "#", fileName, monad.rawImage)
      whenReady(eventualUnit, timeout) { response =>
        Files.exists(Paths.get(fileName))
      }
    }

  }

}

object ImagingTools {

  def aSeedThatMatches(processingMonad: ImageProcessingMonad[String], position: Position, expectedValue: String): Position = {
    val firstSeed = processingMonad
      .getFirstThatMatches("#")
      .getOrElse(throw new IllegalStateException("# not found"))
    assert(firstSeed == position)
    assert(processingMonad.at(firstSeed) == "#")
    firstSeed
  }

  def writeToFile(processingMonad: ImageProcessingMonad[String], front: List[Position], fileName: String, newContent: String = "@"): Unit =
    ImageWriter.writeToFile(fileName, processingMonad.replace(front, newContent).rawImage)

  object TestImageBuilder {

    def fromString(rawContent: String): ImageProcessingMonad[String] = {
      val contents: List[List[String]] = rawContent
        .split("\n")
        .map(_.toCharArray.toList.map(_.toString))
        .toList
        .filter(_.map(_.trim).mkString.nonEmpty)
      ImageProcessingMonad(RawImage(contents))
    }

  }

}
